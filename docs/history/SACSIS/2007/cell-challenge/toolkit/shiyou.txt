---------------------------------------------------------------------------
Cellスピードチャレンジ2007 規定課題部門 規定課題の詳細         2007-02-14

このファイルは2つの章により構成されています．それぞれをよく読んでください．
質問やバグ情報などは cellspeed2007@arch.cs.titech.ac.jp までお願いします．
---------------------------------------------------------------------------
更新履歴

2007-02-13:
「5. リストからキーを得るための計算」の一部を修正しました．
正しくは，keytype=1の時が2乗の和，keytype=2の時が最大値です．

2007-02-14:
「6. SPEのプログラミング」にデクリメンタの制約を追加しました．
処理時間の計測のためにSPEのデクリメンタを利用しています．
このため，参加者がデクリメンタの値を変更することを禁止します．
spu_write_decrementer関数を利用してはいけません．
一方，デクリメンタの値を読むことは自由です．

---------------------------------------------------------------------------

【第１章 ソーティングに関する仕様】

---------------------------------------------------------------------------
1. ソーティングの入力データ形式

多数のデータの系列が入力として与えられたときに，これらをある順序にしたがっ
て並び替える処理をソーティングと呼びます．
ソーティングの対象となる1つのデータを要素(element)と呼ぶことにします．
この要素には1つのキー(key)とある長さをもつリスト(list)が含まれます．
これらキーとリストは単精度の浮動小数点数です．
リストの長さをMという変数あるいは定数で表現すると，要素は，C言語の構造体を
用いて次の様に表現できます．

struct element{
    float key;
    float list[M];
};

説明を簡潔にするために構造体を利用して表現しましたが，実際には，入力データ
の要素に含まれるリストの長さMは固定された値ではなく，プログラムが起動して
から与えられることになります．
---------------------------------------------------------------------------
2. 利用できるメインメモリの容量は入力データの2倍 + 16KB

ソーティングすべき要素の数をNという変数あるいは定数で表現すると，
入力データの容量は，要素のN倍ですから， sizeof(struct element) * N バイト
として計算できます．ここで sizeofは，オブジェクトを格納するために必要な
バイト数を求める演算子です．
要素のバイト数は (1 + M) * 4 として計算できるので，
入力データの容量は， ((1 + M) * 4) * N バイトとして得ることもできます．
float型の1要素が4バイトであることに注意してください．

ユーザが利用できるメインメモリの容量は入力データの2倍 + 16KBとします．
具体的には，次の様に入力データの2倍の容量の配列と，
16KBの配列を定義して，これらのメインメモリを利用することとします．

volatile static char  buf_ctrl[16 * 1024] _ALIGN; // 16KB memory
volatile static float buf_data[(1+M)*N*2] _ALIGN; // 

16KBのメモリは同期処理などにおける利用を想定したものです．この領域を
利用しなくてもかまいません．

これらの配列以外のメインメモリの領域をアクセスしてはいけません．
ただし，SPE間のDMA転送などのために特別に確保したメモリ領域は利用すること
ができます．詳細はツールキットを参照してください．
---------------------------------------------------------------------------
3. 入力データおよび出力データの配置

プログラムの開始時点で，入力データは先に説明した配列の先頭から格納されて
いるものとします．残りのメモリはゼロで初期化されているものとします．
ユーザが利用できるメインメモリの容量は入力データの2倍としているため，
ちょうど先頭から半分のメモリに入力データが格納されていることになります．

ソーティングが終了した時点で，出力データについても配列の先頭から格納する
こととします．ただし正しくソーティングされた状態で格納されていなければなり
ません．この時，配列の後半のメモリにはどのような値が格納されていてもかまい
ません．
---------------------------------------------------------------------------
4. リストの長さに関する制約

先に説明したように，ソーティングの要素には1つのキーとある長さをもつリスト
が含まれます．任意の長さのリストを考えると，データ転送の整列やサイズなどの
調整のための煩雑な処理が必要となります．この問題を回避するため，1つの要素
のサイズが次式になるように制約を加えます．

sizeof(struct element) = 2 ^ m (2のm乗，単位はバイトです）
m = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}

すなわち，1つの要素のサイズは16Bから16KBの範囲で，16Bの倍々となる値しか
とり得ないこととします．これにより，1つの要素の転送がDMAの最大転送サイズの
16KBを超えることがなくなります．
---------------------------------------------------------------------------
5. リストからキーを得るための計算

入力データは要素の配列として与えられますが，それらのキーに対応する部分の
値はゼロで初期化されています．
ユーザはソーティングを開始する前に，リストからキーの値を生成しなければ
なりません．
リストからキーを計算する方式はプログラムの開始時に与えられます．
次の2つのうちのどちらを利用するかは変数keytypeとして与えられます．

(keytype=1) リストに含まれるすべての値の2乗の和
key = list[0]*list[0] + list[1]*list[1] +, ... , + list[M-1] * list[M-1]

(keytype=2) リストに含まれるすべての値の最大値
key = max{list[j]}, (j=0,1,2, ... , M-1)

このため，今回のソーティングには，次の2つが含まれることに注意してください．
(1) 入力リストからキーを生成する処理
(2) キーの値が昇順になるように要素を並び替える処理(狭い意味のソーティング)

キー，リストの要素はともに単精度の浮動小数点数として表現されます．
また，それぞれの要素の先頭の4バイトにキーが格納されるものとし，残りに
リストが格納されるものとします．
---------------------------------------------------------------------------
6. SPEのプログラミング

処理時間の計測のためにSPEのデクリメンタを利用しています．
このため，参加者がデクリメンタの値を変更することを禁止します．
spu_write_decrementer関数を利用してはいけません．
一方，デクリメンタの値を読むことは自由です．

SPEのプログラムでは，次の情報を受け取り利用することができます．
利用できる情報の詳細は提供されるツールキットを参照してください．

struct spe_ctrl{
    unsigned int id;       // SPEの識別番号 0〜7の固有の値が与えられる．
    unsigned int spe_num;  // SPEの個数で，7に固定される．
    unsigned int buf_addr; // 配列の先頭アドレス
    unsigned int datanum;  // ソーティングすべき要素の数 N
    unsigned int listnum;  // リストの長さ M
    unsigned int keytype;  // リストからキーを計算する方式を指定する変数．
}
---------------------------------------------------------------------------
7. PPEのソースコード変更の禁止

SPEを活用しなければCell BEの高い性能を達成することは困難です．
SPEのプログラミングに集中するために，ユーザはSPEのプログラムのみを提出する
ものとします．
すなわち，提供するPPEのプログラムを変更することを禁止します．
PPEのプログラムについてはある程度の機能を提供するものを実行委員会から
提供します．

どうしてもPPEのプログラムの修正が必要となる場合には，PPEのコードを変更する
かどうかを実行委員会にて検討します．変更を希望する箇所を明確にして 
cellspeed2007@arch.cs.titech.ac.jp に連絡してください．
---------------------------------------------------------------------------
8. ソースコードの提出方法

提出するプログラムは，指定する時刻までにホームディレクトリ下のsubmitという
名前のディレクトリに保存してください．ただし，そのままのファイルでは，
すべての参加者が参照可能になってしまいます．そのため，暗号化してから
誰でも参照できるディレクトリに格納することにします．

まず，提出用のディレクトリ submit を作成して，ホームディレクトリおよび
提出用のディレクトリへのアクセス権を与えます．

$ cd ~
$ mkdir ~/submit
$ chmod 755 .
$ chmod 755 ~/submit

作業している任意のディレクトリで提出するファイルをまとめます．
ホームディレクトリのアクセス権が変更されています．作業をおこなっている
ディレクトリにはユーザのみが参照できるように適切に権限を設定してください．

提出するファイルには少なくとも次のファイルが保存されていなければなりません．
(1) Makefile
(2) spe1.c 
(3) spe.h
Makefileにおけるコンパイラの最適化オプションを変更してもかまいません．
それぞれのSPEが起動するプログラムの名前は spe.h において指定してください．

また，必要であれば (4)SPEごとに作成したソースコードが含まれていても
かまいません．
(4) spe2.c spe3.c spe4.c spe5.c spe6.c spe7.c

これらのファイルを tar というコマンドでまとめます．

$ tar cvfz submit.tgz Makefile spe1.c spe.h

(4)のファイルが必要となる場合には，これらのファイルも一緒にまとめて
ください．
$ tar cvfz submit.tgz Makefile spe1.c spe.h spe2.c spe3.c ...

次に，まとめた submit.tgz を暗号化します．このためのパスワードは
それぞれの参加チームに電子メールにて送信します．

$ gpg -c submit.tgz

暗号化のためのパスワード（パスフレーズ）を聞かれるので，受け取った
パスワードを2回入力してください．
submit.tgz.pgp というファイルが生成されます．
このファイルを提出用のディレクトリにコピーすれば完了です．

$ cp submit.tgz.pgp ~/submit

celldev3.celltsb.comマシン上（の任意のディレクトリ）で make コマンドを用
いて実行コードを生成できない場合には失格となります．注意してください．
---------------------------------------------------------------------------

【第２章 スピードチャレンジの形式に関する仕様】

---------------------------------------------------------------------------
1. 予選ラウンド

2月の上旬に「規定課題の詳細（このファイル）とツールキット」を公開します．
ツールキットには，異なる特徴をもつ5種類の入力データが含まれています．
ツールキットに含まれるこれらの問題を「練習問題」と呼ぶことにします．
予選ラウンドが終了するまで，練習問題の入力データを生成する関数のソース
コードは提供しません．
練習問題を生成する関数はライブラリ（オブジェクト）として提供されます．

予選ラウンドに提出するプログラムは，これら5種類の全ての練習問題について
正しい出力（ソーティング結果）を得るプログラムでなくてはなりません．
1つでも，間違った結果を生成する場合には，残念ながら，予選ラウンドにて
失格となり，決勝ラウンドに出場することはできません．

予選ラウンドに提出するプログラムは，2007年3月9日午後8時までに，
ホームディレクトリ下のsubmitという名前のディレクトリに保存してください．


予選ラウンドでは，まず，練習問題を利用して提出されたプログラムが正しい
ことを確認します．
その後に，予選ラウンドのために特別に準備する5種類の「予選ラウンド問題」
を用いて，それぞれの参加チームのプログラムを評価します．
5種類の予選ラウンド問題のそれぞれについて，実行時間の速いものから順に，
以下の点数を与えます．
・1位 6点
・2位 4点
・3位 3点
・4位 2点
・5位 1点

予選ラウンドの評価においては打ち切り時間を設けます．この時間内に結果が
得られない場合に点数を得ることはできません．
具体的には，次のコマンドによりプログラムを評価します．
$ cellexec -t 60 main (argument)
ここでは60秒という打ち切り時間を指定していますが，この値は状況により
調整することがあります．

この予選ラウンドで獲得した得点と，決勝ラウンドで獲得した得点の合計が
多いチームが優勝となります．

予選ラウンドが終了してから，練習問題と予選ラウンド問題の入力データを
生成する関数のソースコードを公開します．デバッグやチューニングのため
に活用してください．
また，チーム名と予選ラウンド問題の実行時間，獲得点数といった情報を公開
します．このデータもチューニングの際の参考にしてください．
---------------------------------------------------------------------------
2. 決勝ラウンド

決勝ラウンドに提出するプログラムは，2007年3月28日午後8時までに，
ホームディレクトリ下のsubmitという名前のディレクトリに保存してください．

決勝ラウンドのために特別に準備する10種類の「決勝ラウンド問題」を用いて，
それぞれの参加チームのプログラムを評価します．
10種類の予選ラウンド問題のそれぞれについて，実行時間の速いものから順に，
以下の点数を与えます．
・1位 10点
・2位 7点
・3位 5点
・4位 4点
・5位 3点
・6位 2点
・7位 1点

決勝ラウンドの評価においては打ち切り時間を設けます．この時間内に結果が
得られない場合に点数を得ることはできません．
具体的には，次のコマンドによりプログラムを評価します．
$ cellexec -t 60 main (argument)
ここでは60秒という打ち切り時間を指定していますが，この値は状況により
調整することがあります．

予選ラウンドで獲得した得点と，決勝ラウンドで獲得した得点の合計が多い
チームが優勝となります．なお，すべての問題を1位で通過した場合の最高得点
は130点です．
---------------------------------------------------------------------------
3. スピードチャレンジ規定課題部門の進め方の概要

予選ラウンド，決勝ラウンドの役割とスピードチャレンジの進め方をまとめる
と下のようになります．
......................................................................
●予選ラウンド

2月の上旬にツールキット（練習問題）の公開

2007年3月9日午後8時 予選ラウンドのプログラム提出

練習問題を全てクリア
       |
  Yes --- No  -----> 失格
  |
決勝ラウンドに参加する権利を獲得
予選ラウンド問題の実行速度により点数を獲得

......................................................................
●決勝ラウンド

2007年3月28日午後8時 決勝ラウンドのプログラム提出

決勝ラウンド問題の実行速度により点数を獲得

予選ラウンドと決勝ラウンドの合計得点で優勝者を決定
......................................................................
---------------------------------------------------------------------------
質問やバグ情報などは cellspeed2007@arch.cs.titech.ac.jp までお願いします．
マルチコアプログラミングコンテスト「Cellスピードチャレンジ2007」実行委員会
http://www.hpcc.jp/sacsis/2007/cell-challenge/
---------------------------------------------------------------------------
